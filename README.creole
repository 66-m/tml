Just a try to create a library for handling teeworlds map files.

== Usage
Please note this should work in future, it does currently not. This is an example for later.
{{{
>>> from teemap import Teemap
>>> t = Teemap()
>>> t.load("maps/dm1.map")
>>> t.layers
# list of layers
>>> t.groups
# list of groups
>>> t.images[0].name
# 'sun'
# ...
}}}

== The mapformat
In this section I describe my current state of knowledge about how a teeworlds
map is structured.

=== Header
The first bytes just contain the word "DATA" or "ATAD" (little oder big endian),
it is the "signature" of a teeworlds map. After that there is an int which
contains the version of the mapformat, teeworlds 0.5 uses version 4 but also
supports 3, this libary only supports 4.
{{{
DATA\x04\x00\x00\x00
}}}
Then there are four more ints which can be read straight from the file.
These are "size", "swaplen", "num_item_types", "num_items", "num_raw_data",
"item_size" and "data_size".

Now the size of the whole header can be calculated. This is important to
skip the header and go directly to the items and datas themself. It is the sum of the
following:
* num_item_types * 12 (one item type is composed of three int, one int is four bits)
* (num_items + num_raw_data) * 4
* num_raw_data * 4
* item_size

=== Types
After the header the types are stored. For each item type there is a list containing
the type, the number of items for this type and which itme is the first for this type.

=== Item offsets
Right after the types the item offsets are stored. The first offset is 0. The offset
to the next item will be the size of the previous item. The size of each item is as big
as defined in "mapitems.h" (see teeworlds source) plus 2 more integers containing the type,
id and the item size. Type and id is within the dirst integer.
There allways is one "envpoint" item with a dynamic size. It consists of the 2 integers
and type size multiplicated with the number od envpoints.

=== Uncompressed data sizes
The uncompressed data sizes are stored after the item offsets. The sizes are used
to allocate the memory for each data in teeworlds.

=== Items
Finally the items are stored. Every item will be written with all its data in a sorted
order. First the version, then the images, then the envelops, then the groups. After this
the layers and finally the envpoints are stored.

=== Compressed data
Eventually the compressed data is stored. Every item with (images and layers) will have an
index wich tells the item which data is to load.
The compressed data part stores image names, tiles, quads and embedded images.
